package com.perls3.bellesvues.utilies;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.location.Address;
import android.location.Geocoder;
import android.location.Location;
import android.net.Uri;
import android.preference.PreferenceManager;
import android.util.Log;
import android.view.View;

import androidx.annotation.Keep;
import androidx.annotation.NonNull;
import androidx.camera.core.CameraSelector;
import androidx.camera.core.ImageCapture;
import androidx.camera.core.ImageCaptureException;
import androidx.camera.core.Preview;
import androidx.camera.lifecycle.ProcessCameraProvider;
import androidx.camera.view.PreviewView;
import androidx.lifecycle.LifecycleOwner;
import androidx.navigation.NavDirections;
import androidx.navigation.Navigation;

import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.tasks.Continuation;
import com.google.android.gms.tasks.OnCompleteListener;
import com.google.android.gms.tasks.OnFailureListener;
import com.google.android.gms.tasks.OnSuccessListener;
import com.google.android.gms.tasks.Task;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.storage.FirebaseStorage;
import com.google.firebase.storage.StorageReference;
import com.google.firebase.storage.UploadTask;
import com.perls3.bellesvues.App;
import com.perls3.bellesvues.fragments.PictureFragmentDirections;
import com.perls3.bellesvues.view_models.AlertViewModel;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;


public class CameraXmanipulation {

    @Keep

    private static final String TAG = CameraXmanipulation.class.getSimpleName();
    public static ImageCapture imageCapture;
    public static File fileX;
    public static Uri downloadUri;


    // get the Executor using Contextcompact.getMainExecutor(requireContext());

    public static void startCamera(PreviewView previewView, Executor executor, Context requireContext) {

        // -1- First Step get the  ProcessCameraProvidersingleton  and check if its ready to use

        //ListenableFuture<T> let you add a listener to T that run on an Executor after T has completed
        ListenableFuture<ProcessCameraProvider> cameraProvideFuture = ProcessCameraProvider.getInstance(requireContext);


        // -2- add listener to processCameraprovider that will run when processCameraprovider is completed


        cameraProvideFuture.addListener(() -> {


            try {
                ProcessCameraProvider cameraProvider = cameraProvideFuture.get();

                // -3- build the Preview and add a surface *provider to it, don't forget to use createSurfaceProvider and not getSurfaceProvide

                Preview preview = new Preview.Builder()
                        .build();
                preview.setSurfaceProvider(previewView.createSurfaceProvider());

                //build the imageCapture

                imageCapture = new ImageCapture.Builder()
                        .build();

                // -4- select which camera to use it , front or back

                CameraSelector cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA;

                cameraProvider.unbindAll();// unBallAll is so important
                cameraProvider.bindToLifecycle((LifecycleOwner) requireContext, cameraSelector, preview, imageCapture);
            } catch (ExecutionException | InterruptedException e) {
                e.printStackTrace();
                Log.e(TAG, "failed to get ProcessCameraProvider");
            }


        }, executor);


    }

    /**
     * hello dear.
     * {@code takePicture } is a static method that make a picture.
     *
     * @param imageCapture   A use case for taking a picture.
     *                       This class is designed for basic picture taking. It provides takePicture() functions to take a picture to memory or save to a file, and provides image metadata. Pictures are taken in automatic mode after focus has converged. The flash mode can additionally be set by the applicatio
     * @param cameraExecutor a ui executor where the picture will be taken
     * @param requiredView   the view generated by the fragment
     * @param reqContext     the fragment
     * @return void
     * @throws NoSuchFieldError
     * @link com.perls3.bellesvues.fragments.PictureFragment
     * used in { @see com.perls3.bellesvues.fragments.PictureFragment}
     */

    public static void takePicture(ImageCapture imageCapture, Executor cameraExecutor, View requiredView, Context reqContext, AlertViewModel alertViewModel, Activity activity) {
        String path = "";
        // Create time-stamped output file to hold the image

        // Date currentTime = Calendar.getInstance().getTime();




        ImageCapture.OutputFileOptions outputFileOptions =
                null;
        try {
            fileX = new File("files" + File.separator + "at" + System.currentTimeMillis() + ".jpg");


            FileOutputStream fos = null;
            fos = App.context.openFileOutput(fileX.getName(), Context.MODE_APPEND);

            //if (!fileX.mkdirs()) {
            path = fileX.getAbsolutePath();
            Log.e(TAG, path);
            //}
            //   if (fileX.mkdirs()) {
            outputFileOptions = new ImageCapture.OutputFileOptions.Builder(fos).build();


            //} else {
            //  Log.e(TAG,"the files was not created  !!!");

            //}
        } catch (Exception e) {
            e.printStackTrace();
        }


        // Set up image capture listener, which is triggered after photo has
        // been taken
        if (outputFileOptions != null) {

            String finalPath = path;
            imageCapture.takePicture(outputFileOptions,
                    cameraExecutor,
                    new ImageCapture.OnImageSavedCallback() {
                        @Override
                        public void onImageSaved(@NonNull ImageCapture.OutputFileResults outputFileResults) {

                            NavDirections action = PictureFragmentDirections.actionPictureFragmentToAlertFragment2();
                            Navigation.findNavController(requiredView).navigate(action);
                   //         alertViewModel.insertAllRequests(
                     //               new RequestsEntity(String.valueOf(System.currentTimeMillis())
                       //                     , "test"
                         //                   , "hello"
                           //                 , finalPath
                             //               , false
                               //             , String.valueOf(FirebaseAuth.getInstance().getCurrentUser().getEmail())));

                            FirebaseStorage firebaseStorage = FirebaseStorage.getInstance();

                            // Create a Cloud Storage reference from the app
                            StorageReference storageRef = firebaseStorage.getReference();
                            // Create a reference to "mountains.jpg"
                            StorageReference mountainsRef = storageRef.child("pictures" + System.currentTimeMillis());

// Create a reference to 'images/mountains.jpg'
                            StorageReference mountainImagesRef = storageRef.child("images/" + "pictures" + System.currentTimeMillis());

// While the file names are the same, the references point to different files
                            mountainsRef.getName().equals(mountainImagesRef.getName());    // true
                            mountainsRef.getPath().equals(mountainImagesRef.getPath());    // false

                            InputStream inputStream = null;
                            try {
                                inputStream = App.context.openFileInput(fileX.getName());

                                //  inputStream = new FileInputStream(fileX);
                            } catch (FileNotFoundException e) {
                                e.printStackTrace();
                            }
                            if (inputStream != null) {
                                UploadTask uploadTask = mountainImagesRef.putStream(inputStream);
                                Task<Uri> urlTask = uploadTask.continueWithTask(new Continuation<UploadTask.TaskSnapshot, Task<Uri>>() {

                                    @Override
                                    public Task<Uri> then(@NonNull Task<UploadTask.TaskSnapshot> task) throws Exception {
                                        if (!task.isSuccessful()) {
                                            throw task.getException();
                                        }     // Continue with the task to get the download URL
                                        return mountainImagesRef.getDownloadUrl();
                                    }
                                }).addOnCompleteListener(new OnCompleteListener<Uri>() {
                                    @Override
                                    public void onComplete(@NonNull Task<Uri> task) {
                                        if (task.isSuccessful()) {
                                            FusedLocationProviderClient fusedLocationProviderClient=LocationServices.getFusedLocationProviderClient(reqContext);
                                            @SuppressLint("MissingPermission") Task<Location> LocationTask =fusedLocationProviderClient.getLastLocation();
                                            LocationTask.addOnSuccessListener(new OnSuccessListener<Location>() {
                                                @Override
                                                public void onSuccess(Location location) {
                                                    if (location!=null) {
                                                        Geocoder geocoder = new Geocoder(reqContext);
                                                        List<Address> addresses = null;

                                                        try {


                                                            addresses = geocoder.getFromLocation(
                                                                    location.getLatitude(),
                                                                    location.getLongitude(),
                                                                    // In this sample, we get just a single address.
                                                                    1);

                                                        } catch (IOException e) {
                                                            e.printStackTrace();
                                                        }

                                                        downloadUri = task.getResult();
                                                        SharedPreferences sharedPref = activity.getPreferences(Context.MODE_PRIVATE);
                                                        String UserEmail = sharedPref.getString("UserEmail","");
                                                        String UserNoun = sharedPref.getString("UserNoun","");
                                                        String phoneNumbe = sharedPref.getString("phoneNumber","");
                                                        FirebaseFirestore db = FirebaseFirestore.getInstance();
                                                        Map<String, Object> user = new HashMap<>();
                                                        //never put the same name as the ^ the map  , never use user^^ user >>
                                                        user.put("theUsName", UserNoun);
                                                        user.put("theUsPhoneNumber", Objects.requireNonNull(phoneNumbe));
                                                        user.put("email", UserEmail);
                                                        user.put("date", String.valueOf(Calendar.getInstance().getTime()));
                                                        user.put("location", String.valueOf(location));
                                                        user.put("longitude", location.getLongitude());
                                                        user.put("latitude", location.getLatitude());
                                                        user.put("address", String.valueOf(addresses));
                                                        user.put("comment", "hello");
                                                        user.put("pictureURL", downloadUri.toString());
                                                        user.put("isResolved", false);

                                                        db.collection("users")
                                                                .add(user)
                                                                .addOnSuccessListener(new OnSuccessListener<DocumentReference>() {
                                                                    @Override
                                                                    public void onSuccess(DocumentReference documentReference) {
                                                                        Log.e("CameraXmanipulation", "collection made in firestore");

                                                                    }
                                                                }).addOnFailureListener(new OnFailureListener() {
                                                            @Override
                                                            public void onFailure(@NonNull Exception e) {
                                                                Log.e("CameraXmanipulation", "collection not made in firestore !!!!");

                                                            }
                                                        });
                                                    }

                                                }
                                            });




                                        } else {
                                            // Handle failures
                                            // ...
                                            Log.e("CameraXmanipulation", "Task is failed here");
                                            Log.e("CameraXmanipulation", "location is null");
                                        }
                                    }
                                });


                            } else Log.e("CameraXmanipulation", "inputStream==" + inputStream);


                        }

                        @Override
                        public void onError(@NonNull ImageCaptureException exception) {
                            Log.e(TAG, "images was not saved" + exception);
                            exception.printStackTrace();

                        }
                    });
        } else Log.e(TAG, "outputFileOptions is null");


    }

    static final String KEY_REQUESTING_LOCATION_UPDATES = "requesting_locaction_updates";

    /**
     * Returns true if requesting location updates, otherwise returns false.
     *
     * @param context The {@link Context}.
     */
    public static boolean requestingLocationUpdates(Context context) {
        return PreferenceManager.getDefaultSharedPreferences(context)
                .getBoolean(KEY_REQUESTING_LOCATION_UPDATES, false);
    }

    /**
     * Stores the location updates state in SharedPreferences.
     *
     * @param requestingLocationUpdates The location updates state.
     */
    public static void setRequestingLocationUpdates(Context context, boolean requestingLocationUpdates) {
        PreferenceManager.getDefaultSharedPreferences(context)
                .edit()
                .putBoolean(KEY_REQUESTING_LOCATION_UPDATES, requestingLocationUpdates)
                .apply();
    }

    /**
     * Returns the {@code location} object as a human readable string.
     *
     * @param location The {@link Location}.
     */
    static String getLocationText(Location location) {
        return location == null ? "Unknown location" :
                "(" + location.getLatitude() + ", " + location.getLongitude() + ")";
    }


}



